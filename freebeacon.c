/*
  freebeacon.c
  Original by David Rowe VK5DGR
  Hamlib PTT and 700C support was by Bob VK4YA
  Tx & 700E Alan VK2ZIW
  Stores data from Rx into array and to later Tx from that array
  Modes 700D and 700E
  FreeDV Beacon and store and retransmit Repeater.
*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <termios.h>
#include <sys/ioctl.h>
#endif

#include <samplerate.h>
#include <getopt.h>

#include "sndfile.h"
#include "portaudio.h"

#include "codec2_fifo.h"
#include "modem_stats.h"
#include "freedv_api.h"
#include "freedv_api_internal.h"
#include "codec2.h"
#include "reliable_text.h"
#include "hamlib/rig.h"

#define MAX_CHAR            80
#define MAX_CHAR2           200
#define FS8                 8000                // codec audio sample rate fixed at 8 kHz
#define FS48                48000               // 48 kHz sampling rate rec. as we can trust accuracy of sound card
#define SYNC_TIMER          2.0                 // seconds of valid rx sync we need to see to change state
#define UNSYNC_TIMER        2.0                 // seconds of lost sync we need to see to change state
#define COM_HANDLE_INVALID   -1
#define LOG_TIMER           1.0
#define SNR_MIN             3.0                 // 700E, sync is problematic without SQ enabled
#define SQ_LEVEL            0.3
#define METRIC              0.35
#define SERVICE_PORT        21234
#define IP_ADDRESS          "192.168.20.122"

/* globals used to communicate with async events and callback functions */

volatile int keepRunning, runListener, recordAny;
char txtMsgTx[MAX_CHAR], *ptxtMsgTx;
char txtMsgRx[MAX_CHAR], *ptxtMsgRx, triggerString[MAX_CHAR], GtimeStr[MAX_CHAR];
int triggered, txFromNet, beaconTimer, beaconInt;
float snr_est, snr_sample;
int com_handle, verbose;
struct FIFO          *nfifo;

/* state machine defines */

#define SRX_IDLE          0      /* listening but no FreeDV signal                                   */
#define SRX_MAYBE_SYNC    1      /* We have sync but lets see if it goes away                        */
#define SRX_SYNC          2      /* We have sync on a valid FreeDV signal                            */
#define SRX_MAYBE_UNSYNC  3      /* We have lost sync but lets see if it's really gone               */
#define STX               4      /* transmitting reply                                               */

char *state_str[] = {
    "Rx Idle",
    "Rx Maybe Sync",
    "Rx Sync",
    "Rx Maybe UnSync",
    "Tx"
};


int openComPort(const char *name);
void closeComPort(void);
void raiseDTR(void);
void lowerDTR(void);
void raiseRTS(void);
void lowerRTS(void);
pthread_t start_udp_listener_thread(void);

/* hamlib static vars */

hamlib_port_t myport;
RIG *my_rig;
rig_model_t myrig_model;        // int
int retcode;

FILE *reliable_tx_fp, *ftxt_rx = NULL;
int  use_reliabletext = 1;
bool reliable_txt_rxd = false; 
reliable_text_t reliable_text_obj;

struct my_callback_state {
    char  tx_str[80];
    char *ptx_str;
    int calls;
};


/*--------------------------------------------------------------------------------------------------------*\

                                                  FUNCTIONS

\*--------------------------------------------------------------------------------------------------------*/

/* Called on Ctrl-C */

void intHandler(int dummy) {
    keepRunning = 0;
    fprintf(stderr,"\nShutting Down ......\n");
}

/* returns number of output samples generated by resampling */

int resample(SRC_STATE *src,
            short      output_short[],
            short      input_short[],
            int        output_sample_rate,
            int        input_sample_rate,
            int        length_output_short, // maximum output array length in samples
            int        length_input_short
            )
{
    SRC_DATA src_data;
    float    input[length_input_short];
    float    output[length_output_short];

    assert(src != NULL);

    src_short_to_float_array(input_short, input, length_input_short);

    src_data.data_in = input;
    src_data.data_out = output;
    src_data.input_frames = length_input_short;
    src_data.output_frames = length_output_short;
    src_data.end_of_input = 0;
    src_data.src_ratio = (float)output_sample_rate/input_sample_rate;
    //printf("%d %d src_ratio: %f \n", length_input_short, length_output_short, src_data.src_ratio);

    src_process(src, &src_data);

    assert(src_data.output_frames_gen <= length_output_short);
    src_float_to_short_array(output, output_short, src_data.output_frames_gen);

    return src_data.output_frames_gen;
}


void listAudioDevices(void) {
    const PaDeviceInfo *deviceInfo = NULL;
    int                 numDevices, devn;

    numDevices = Pa_GetDeviceCount();
    printf("Num                                               Name      API   InCh  OutCh  DefFs\n");
    printf("====================================================================================\n");
    for (devn = 0; devn<numDevices; devn++) {
        deviceInfo = Pa_GetDeviceInfo(devn);
        if (deviceInfo == NULL) {
            fprintf(stderr, "Couldn't open devNum: %d\n", devn);
            return;
        }
        printf(" %2d %50s %8s %6d %6d %6d\n",
               devn,
               deviceInfo->name,
               Pa_GetHostApiInfo(deviceInfo->hostApi)->name,
               deviceInfo->maxInputChannels,
               deviceInfo->maxOutputChannels,
               (int)deviceInfo->defaultSampleRate);
    }
}


void printHelp(const struct option* long_options, int num_opts, char* argv[])
{
	int i;
	char *option_parameters = NULL;

	fprintf(stderr, "\nFreeBeacon - FreeDV Beacon\n"
		"usage: %s [OPTIONS]\n\n"
                "Options:\n"
                "\t-i        (Disable beacon ident)\n"
                "\t-b num    (Enable beacon interval)\n"
                "\t-c        (comm port for Tx or CAT PTT)\n"
                "\t-r        (Hamlib CAT model number [use rigctl -l to see list])\n"
                "\t-l --list (audio devices)\n"
                "\t-m --mode 1600|700C|700D|700E\n"
                "\t-t        (tx on start up, useful for testing)\n"
                "\t-u        (Stop UDP listener)\n"
                "\t-q num    (SQ_LEVEL)\n"
                "\t-f num    (FECmax errors)\n"
                "\t-v        (verbose)\n", argv[0]);
        for(i=0; i<num_opts-1; i++) {
		if(long_options[i].has_arg == no_argument) {
			option_parameters="";
		} else if (strcmp("dev", long_options[i].name) == 0) {
			option_parameters = " DeviceNumber (-l --list to list devices)";
                } else if (strcmp("trigger", long_options[i].name) == 0) {
			option_parameters = " textString (used to trigger beacon)";
                } else if (strcmp("callsign", long_options[i].name) == 0) {
			option_parameters = " callsign (returned in text str to tx)";
                } else if (strcmp("txfilename", long_options[i].name) == 0) {
			option_parameters = " wavefile (to use for source audio on tramsmit)";
                } else if (strcmp("samplerate", long_options[i].name) == 0) {
			option_parameters = " sampleRateHz (audio device sample rate)";
                } else if (strcmp("wavefilewritepath", long_options[i].name) == 0) {
			option_parameters = " pathToWaveFiles (path to where wave files are written)";
                } else if (strcmp("rpigpio", long_options[i].name) == 0) {
			option_parameters = " GPIO (BCM GPIO number on Raspberry Pi for Tx PTT)";
                } else if (strcmp("rpigpioalive", long_options[i].name) == 0) {
			option_parameters = " GPIO (BCM GPIO number on Raspberry Pi for alive blinker)";
                } else if (strcmp("statuspagefile", long_options[i].name) == 0) {
			option_parameters = " statusPageFileName (where to write status web page)";
                } else if (strcmp("ip_address", long_options[i].name) == 0) {
			option_parameters = " ipAddressString (where to send Rx to via port 21234)";
                }
		fprintf(stderr, "\t--%s%s\n", long_options[i].name, option_parameters);
	}

	exit(0);
}

void getTimeStr(char TimeStr[]) {
    time_t ltime;     /* calendar time */
    struct tm *loctime;

    ltime=time(NULL); /* get current cal time */
    loctime = localtime (&ltime);
    strftime(TimeStr, MAX_CHAR, "%F-%H-%M-%S",loctime);
}


/* text message callbacks */
// void my_put_next_rx_char(void *states, char c) { fprintf(stderr, "%c", c); } 

void callbackNextRxChar(void *callback_state, char c) {

    /* if we hit end of buffer wrap around to start */

    if ((ptxtMsgRx - txtMsgRx) < (MAX_CHAR-1))
        *ptxtMsgRx++ = c;
    else
        ptxtMsgRx = txtMsgRx;

    /* if end of string let see if we have a match for the trigger
       string.  Note tx may send trigger string many times.  We only
       need to receive it once to trigger a beacon tx cycle. */

    if ( c == 13) {
        reliable_txt_rxd = false;
        *ptxtMsgRx++ = c;
        *ptxtMsgRx = 0;
         ptxtMsgRx = txtMsgRx;
         if (verbose)
             fprintf(stderr, "  RX txtMsg: %s:\n", txtMsgRx);
         if (strstr(txtMsgRx, triggerString) != NULL) {
             triggered = beaconTimer = 1;
             snr_sample = snr_est;
             if (verbose) {
                 getTimeStr(GtimeStr);
                 fprintf(stderr, "\n  Tx triggered! %s\n", GtimeStr);
             }
         }
    }
}

char callbackNextTxChar(void *callback_state) {
    if ((*ptxtMsgTx == 0) || ((ptxtMsgTx - txtMsgTx) >= MAX_CHAR))
        ptxtMsgTx = txtMsgTx;

    //fprintf(stderr, "TX txtMsg: %d %c\n", (int)*ptxtMsgTx, *ptxtMsgTx);
    return *ptxtMsgTx++;
}


SNDFILE *openPlayFile(char fileName[], int *sfFs)
{
    SF_INFO  sfInfo;
    SNDFILE *sfPlayFile;

    sfInfo.format = 0;

    sfPlayFile = sf_open(fileName, SFM_READ, &sfInfo);
    if(sfPlayFile == NULL) {
        const char *strErr = sf_strerror(NULL);
        fprintf(stderr, " %s Couldn't open: %s\n", strErr, fileName);
    }
    *sfFs = sfInfo.samplerate;

    return sfPlayFile;
}


SNDFILE *openRecFile(char fileName[], int sfFs)
{
    SF_INFO  sfInfo;
    SNDFILE *sfRecFile;

    sfInfo.format     = SF_FORMAT_WAV | SF_FORMAT_PCM_16;
    sfInfo.channels   = 1;
    sfInfo.samplerate = sfFs;

    sfRecFile = sf_open(fileName, SFM_WRITE, &sfInfo);
    if(sfRecFile == NULL) {
        const char *strErr = sf_strerror(NULL);
        fprintf(stderr, " %s Couldn't open: %s\n", strErr, fileName);
    }

    return sfRecFile;
}


/* Use the Linux /sys/class/gpio system to access the RPis GPIOs */

void sys_gpio(char filename[], char s[]) {
    FILE *fgpio = fopen(filename, "wt");
    //fprintf(stderr,"%s %s\n",filename, s);
    if (fgpio == NULL) {
      fprintf(stderr, "\nProblem opening %s\n", filename);
        exit(1);
    }
    fprintf(fgpio,"%s",s);
    fclose(fgpio);
}



void hamlib_ptt_on()
{
    printf("Freebeacon: Setting rig PTT ON.\n");
    retcode = rig_set_ptt(my_rig, RIG_VFO_A, RIG_PTT_ON);

    if (retcode != RIG_OK)
    {
        printf("rig_set_ptt: error = %s \n", rigerror(retcode));
    }
}

void hamlib_ptt_off()
{
    printf("Freebeacon: Setting rig PTT OFF.\n");
    retcode = rig_set_ptt(my_rig, RIG_VFO_A, RIG_PTT_OFF);

    if (retcode != RIG_OK)
    {
        printf("rig_set_ptt: error = %s \n", rigerror(retcode));
    }
}

int hamlib_init(rig_model_t myrig_model, char *commport)
{
//  rig_load_all_backends();
//  rig_set_debug(RIG_DEBUG_VERBOSE);
//  rig_set_debug(RIG_DEBUG_TRACE);
    rig_set_debug(RIG_DEBUG_ERR);

    fprintf(stderr,"Freebeacon: Calling Rig Init\n");
    my_rig = rig_init(myrig_model);
    if (!my_rig) {
        fprintf(stderr,"Freebeacon: Hamlib Rig Init FAILED\n");
        return(1);
    }

    strncpy(my_rig->state.rigport.pathname, commport, FILPATHLEN - 1);

    retcode = rig_open(my_rig);
    if (retcode != RIG_OK)
    {
        fprintf(stderr,"Freebeacon: Hamlib rig_open: error = %s\n", rigerror(retcode));
        return(2);
    }

    fprintf(stderr,"Freebeacon: Hamlib Rig opened okay\n");
    return(0);
}
//Reliable text
char my_get_next_tx_char(void *callback_state) {
    struct my_callback_state* pstate = (struct my_callback_state*)callback_state;
    char  c = *pstate->ptx_str++;
    if (*pstate->ptx_str == 0) {
        pstate->ptx_str = pstate->tx_str;
    }

    return c;
}

void on_reliable_text_rx(reliable_text_t rt, const char* txt_ptr, int length, void* state)
{
    sprintf(txtMsgRx, "%s\n", txt_ptr);
    reliable_txt_rxd = true;
    fprintf(stderr, "Reliable text: %s\n", txt_ptr);
    reliable_text_reset(reliable_text_obj);
    if (strstr(txtMsgRx, triggerString) != NULL) {
        triggered = beaconTimer = 1;
        snr_sample = snr_est;
        if (verbose) {
            getTimeStr(GtimeStr);
            fprintf(stderr, "\n  Tx triggered! %s\n", GtimeStr);
        }
    }
}


/*--------------------------------------------------------------------------------------------------------* \

                                                  MAIN

\*--------------------------------------------------------------------------------------------------------*/

int main(int argc, char *argv[]) {
    struct freedv      *f2;
    struct CODEC2      *c2 = NULL;
    unsigned char      *c2bits = NULL; // array of unsigned chars
    unsigned char       c2packed[1000];
    unsigned char      *c2packedp;
    PaError             err;
    PaStreamParameters  inputParameters, outputParameters;
    const PaDeviceInfo *deviceInfo = NULL;
    PaStream           *stream = NULL;
    int                 j, src_error, inputChannels, nin, devNum;
    int                 outputChannels;
    int                 state, next_state;
    SRC_STATE          *rxsrc, *txsrc;
    SRC_STATE          *playsrc;
    struct FIFO        *fifo;
    char                txFileName[MAX_CHAR];
    SNDFILE            *sfPlayFile, *sfRecFileFromRadio, *sfRecFileDecAudio;
    int                 sfFs;
    int                 fssc;
    int                 triggerf, txfilenamef, callsignf, sampleratef, wavefilepathf, rpigpiof, rpigpioalivef;
    int                 statuspagef, ipAddressf;
    int                 sync, haveRecording;
    char                commport[MAX_CHAR];
    char                callsign[10];
    float               syncTimer, logTimer;
    unsigned int        tnout=0,mnout;
    short               peak = 0;
    char                waveFileWritePath[MAX_CHAR];
    char                rpigpio[20], rpigpio_path[MAX_CHAR], rpigpioalive[20], rpigpioalive_path[MAX_CHAR2];
    char                statusPageFileName[MAX_CHAR2], ipAddressString[MAX_CHAR];
    FILE               *fstatus;
    int                 gpioAliveState = 0;
    int                 freedv_mode, ncodec, not_sync;
    int                 ident_en, udp_en;
    struct MODEM_STATS  g_stats;
//  FILE               *ftmp;
// Rx data
    unsigned char       rxData[200000];
    unsigned char      *rxDataCnt;
    unsigned char      *rxDataPtr;
    char                rxDataFileName[MAX_CHAR2];
    FILE               *frxData;
    int                 rxdatanamef;
    int                 nout, nframes;
    int                 FECmax = 4;
    int                 FEClast = 0;
    int                 FECerr = 0;
    float               sq_level = 0.3;
//  unsigned char       aaaa[16] = "aaaaaaaaaaaaaaaa";
    char timeStr[MAX_CHAR];
    int  use_testframes, use_clip, use_txbpf; // use_dpsk;
    /* debug raw file */

//  ftmp = fopen("t.raw", "wb");
//  assert(ftmp != NULL);

    /* Defaults -------------------------------------------------------------------------------*/

    devNum = 0;
    fssc = FS48;
    sprintf(triggerString, "+"); // can not be in callsign //
    sprintf(txFileName, "txaudio.wav");
    sprintf(rxDataFileName, "Startup.700C");
    sprintf(callsign, "VK2ZIW+");
    verbose = 0;
    com_handle = COM_HANDLE_INVALID;
    mnout = 60*FS8;
    state = SRX_IDLE;
    sync = 0;
    *txtMsgTx = 0;
    sfRecFileFromRadio = NULL;
    sfRecFileDecAudio = NULL;
    sfPlayFile = NULL;
    strcpy(waveFileWritePath, ".");
    *rpigpio = 0;
    *rpigpioalive = 0;
    *statusPageFileName = 0;
    *ipAddressString = 0;
    sprintf(ipAddressString, IP_ADDRESS);
    freedv_mode = FREEDV_MODE_700D;
//  c2_mode = FREEDV_MODE_700C;
    recordAny = 1;
    myrig_model = 0;
    my_rig = NULL;
    beaconTimer = 0;
    beaconInt = 5000;
    ident_en = 1;
    udp_en = 1;
// Rx data
    frxData = NULL;
    rxDataCnt = rxDataPtr = rxData;
    nin = nout = 0;

    if (FREEDV_MODE_700E != 13)
        fprintf(stderr, "Wrong include library\n");
    if (Pa_Initialize()) {
        fprintf(stderr, "Port Audio failed to initialize");
        exit(1);
    }

    /* Process command line options -----------------------------------------------------------*/

    char* opt_string = "hlvib:c:u:tm:f:q:"; // short options : = need arg
    struct option long_options[] = {
        { "dev", required_argument, &devNum, 1 },
        { "trigger", required_argument, &triggerf, 1 },
        { "txfilename", required_argument, &txfilenamef, 1 },
        { "rxdataname", required_argument, &rxdatanamef, 1 },
        { "callsign", required_argument, &callsignf, 1 },
        { "samplerate", required_argument, &sampleratef, 1 },
        { "wavefilewritepath", required_argument, &wavefilepathf, 1 },
        { "statuspagefile", required_argument, &statuspagef, 1 },
        { "ip_address", required_argument, &ipAddressf, 1 },
        { "rpigpio", required_argument, &rpigpiof, 1 },
        { "rpigpioalive", required_argument, &rpigpioalivef, 1 },
        { "list", no_argument, NULL, 'l' },
        { "mode", required_argument, NULL, 'm'},
        { "help", no_argument, NULL, 'h' },
        { NULL, no_argument, NULL, 0 }
    };
    int num_opts=sizeof(long_options)/sizeof(struct option);
    sprintf(txtMsgTx, "Trigger with ++ de urcall\r");

    while(1) {
        int option_index = 0;
        int opt = getopt_long(argc, argv, opt_string,
                    long_options, &option_index);
        if (opt == -1)
            break;

        switch (opt) {
        case 0:
            if (strcmp(long_options[option_index].name, "dev") == 0) {
                devNum = atoi(optarg);
            } else if(strcmp(long_options[option_index].name, "trigger") == 0) {
                strcpy(triggerString, optarg);
            } else if(strcmp(long_options[option_index].name, "txfilename") == 0) {
                strcpy(txFileName, optarg);
            } else if(strcmp(long_options[option_index].name, "rxdataname") == 0) {
                strcpy(rxDataFileName, optarg);
            } else if(strcmp(long_options[option_index].name, "callsign") == 0) {
                strcpy(callsign, optarg);
            } else if (strcmp(long_options[option_index].name, "samplerate") == 0) {
                fssc = atoi(optarg);
            } else if (strcmp(long_options[option_index].name, "wavefilewritepath") == 0) {
                strcpy(waveFileWritePath, optarg);
            } else if (strcmp(long_options[option_index].name, "statuspagefile") == 0) {
                strcpy(statusPageFileName, optarg);
            } else if (strcmp(long_options[option_index].name, "ip_address") == 0) {
                strcpy(ipAddressString, optarg);
            } else if (strcmp(long_options[option_index].name, "rpigpio") == 0) {
                strcpy(rpigpio, optarg);
                sys_gpio("/sys/class/gpio/unexport", rpigpio);
                sys_gpio("/sys/class/gpio/export", rpigpio);
                usleep(100*1000); /* short delay so OS can create the next device */
                char tmp[MAX_CHAR2];
                sprintf(tmp,"/sys/class/gpio/gpio%s/direction", rpigpio);
                sys_gpio(tmp, "out");
                sprintf(rpigpio_path,"/sys/class/gpio/gpio%s/value", rpigpio);
                sys_gpio(rpigpio_path, "0");
            } else if (strcmp(long_options[option_index].name, "rpigpioalive") == 0) {
                strcpy(rpigpioalive, optarg);
                sys_gpio("/sys/class/gpio/unexport", rpigpioalive);
                sys_gpio("/sys/class/gpio/export", rpigpioalive);
                usleep(100*1000); /* short delay so OS can create the next device */
                char tmp[MAX_CHAR2];
                sprintf(tmp,"/sys/class/gpio/gpio%s/direction", rpigpioalive);
                sys_gpio(tmp, "out");
                sprintf(rpigpioalive_path,"/sys/class/gpio/gpio%s/value", rpigpioalive);
                sys_gpio(rpigpioalive_path, "0");
            }
            break;

        case 'i':
            ident_en = 0;
            break;

        case 'c':
           strcpy(commport, optarg);
           if (openComPort(commport) != 0) {
                fprintf(stderr, "Can't open comm port: %s\n",commport);
               exit(1);
            }
            break;

        case 'q':
            sq_level = strtof(optarg, NULL);
            break;

        case 'f':
            FECmax = atoi(optarg);
            break;

        case 'b':
            beaconInt = atoi(optarg);
            break;

        case 'r':       // hamlib CAT rig
            myrig_model = atoi(optarg);      // rig number not its name for now
            if ((myrig_model == 0 ) || (com_handle == COM_HANDLE_INVALID)) {
                fprintf(stderr,"No Comm port? use 'c' option before 'u' option\n");
                fprintf(stderr,"Rig Hamlib model numbers found use rigctl -l to see list\n");
                exit(1);
            }
            closeComPort();  // let hamlib use it now
            fprintf(stderr,"Freebeacon: Opening Hamlib with model %d\n",myrig_model);
            if (hamlib_init(myrig_model, commport)) {
                fprintf(stderr,"Hamlib failed to initilise: [use rigctl -l to see list]\n");
                exit(1);
            }
            break;

        case 'h':
            printHelp(long_options, num_opts, argv);
            break;

        case 'u':
            udp_en = atoi(optarg);
            break;

        case 'v':
            verbose = 1;
            break;

        case 't':
            sprintf(txtMsgTx,"tx Test");
            state = STX;
            break;

        case 'l':
            listAudioDevices();
            exit(0);
            break;

        case 'm':
            if (strcmp(optarg, "1600") == 0)
                freedv_mode = FREEDV_MODE_1600;
            else if (strcmp(optarg, "700C") == 0) {
                fprintf(stderr, "700C doesn't support text, so there is no trigger word. "
                        " So we just record the received file every time we get sync");
                recordAny = 1;
                freedv_mode = FREEDV_MODE_700C;
	    }
            else if (strcmp(optarg, "700D") == 0)
                freedv_mode = FREEDV_MODE_700D;
            else if (strcmp(optarg, "700E") == 0)
                freedv_mode = FREEDV_MODE_700E;
            else {
                 fprintf(stderr, "Unknown mode: %s\n", optarg);
                 exit(1);
            }

            break;

       default:
            /* This will never be reached */
            break;
        }
    }
    getTimeStr(timeStr); // get prog start time
    getTimeStr(GtimeStr); // get prog start time

    if (verbose)
        fprintf(stderr, "\nStarted at %s .\n", GtimeStr);

    /* Initialise FreeDV library, Open Sound Device and start processing --------------------------------*/

    use_testframes = 0; use_clip = 0; use_txbpf = 1; // use_dpsk = 0;
    f2 = freedv_open(freedv_mode);
    assert(f2 != NULL);

    /* these are all optional ------------------ */
    freedv_set_test_frames(f2, use_testframes);
    freedv_set_clip(f2, use_clip);
    freedv_set_tx_bpf(f2, use_txbpf);
 // freedv_set_dpsk(f2, use_dpsk);
    freedv_set_verbose(f2, 0);
    freedv_set_eq(f2, 1); /* for 700C/D/E & 800XA */
    assert(f2 != NULL);
/* check for freedv VERSION */

    assert((freedv_get_version() - 16 ) == 0);

    if ((freedv_mode == FREEDV_MODE_700D) || (freedv_mode == FREEDV_MODE_2020)) {
        freedv_set_phase_est_bandwidth_mode(f2, 0);
        // AlanInc1.2 freedv_set_dpsk(f2, 0);
    }
//  if ((freedv_mode == FREEDV_MODE_700C) || (freedv_mode == FREEDV_MODE_700D) || (freedv_mode == FREEDV_MODE_700E)) {
//                  c2_mode = CODEC2_MODE_700C;
//              } else {
//                  c2_mode = CODEC2_MODE_1300;
//              }

//    struct CODEC2 *freedv_get_codec2    (struct freedv *freedv); to get c2 rxData
    c2 = freedv_get_codec2(f2); assert(c2 != NULL);

    freedv_set_squelch_en(f2, 1);
    freedv_set_snr_squelch_thresh(f2, sq_level);

    if (freedv_mode == FREEDV_MODE_700E) 
        freedv_set_clip(f2, 1);

    int   fsm   = freedv_get_modem_sample_rate(f2);     /* modem sample rate                                   */
    int   n8m   = freedv_get_n_nom_modem_samples(f2);   /* nominal modem sample buffer size at fsm sample rate */
    int   n48   = n8m*fssc/fsm;                        /* nominal modem sample buffer size at 48kHz           */
    float dT    = (float)n48/fssc;                     /* period of each sound buffer                         */

    if (verbose)
        fprintf(stderr, "fsm: %d n8m: %d n48: %d port: %d\n", fsm, n8m, n48, SERVICE_PORT);

    short stereo[2*n48];                               /* stereo I/O buffer from port audio                   */
    short rx48k[n48], tx48k[n48];                      /* signals at 48 kHz                                   */
    short rxfsm[n48];                                  /* rx signal at modem sample rate                      */
// Reliable text
    ftxt_rx = stderr;
    if (use_reliabletext) {
      reliable_tx_fp = ftxt_rx;
      if (strlen(callsign) > 7) sprintf(callsign,  "NOCALL");

      reliable_text_obj = reliable_text_create();
      assert(reliable_text_obj != NULL);
      reliable_text_set_string(reliable_text_obj, callsign, strlen(callsign));
      reliable_text_use_with_freedv(reliable_text_obj, f2,
                                    on_reliable_text_rx, NULL);
    } else {
//    freedv_set_callback_txt(freedv, my_put_next_rx_char, NULL, ftxt_rx);
        /* set up callback for txt msg chars */
        struct my_callback_state  my_cb_state;
        sprintf(my_cb_state.tx_str, "%s\r", txtMsgTx);
        my_cb_state.ptx_str = my_cb_state.tx_str;
        my_cb_state.calls = 0;
        freedv_set_callback_txt(f2, callbackNextRxChar, &my_get_next_tx_char, &my_cb_state);
    }

    // freedv_set_callback_data(f2, callbackC2datarx, NULL, NULL);

    fifo = codec2_fifo_create(4*n8m); assert(fifo != NULL);   /* fifo to smooth out variation in demod nin    */
    nfifo = codec2_fifo_create(4*n8m); assert(fifo != NULL);  /* fifo for network audio in                    */

    /* states for sample rate converters */

    rxsrc = src_new(SRC_SINC_FASTEST, 1, &src_error); assert(rxsrc != NULL);
    txsrc = src_new(SRC_SINC_FASTEST, 1, &src_error); assert(txsrc != NULL);
    playsrc = src_new(SRC_SINC_FASTEST, 1, &src_error); assert(playsrc != NULL);

    /* Open Port Audio device and set up config structures -----------------------------------------------------*/

    deviceInfo = Pa_GetDeviceInfo(devNum);
    if (deviceInfo == NULL) {
        fprintf(stderr, "Couldn't get device info from Port Audio for device: %d\n", devNum);
        exit(1);
    }
    if (deviceInfo->maxInputChannels == 1)
        inputChannels = 1;
    else
        inputChannels = 2;

    /* input device */

    inputParameters.device = devNum;
    inputParameters.channelCount = inputChannels;
    inputParameters.sampleFormat = paInt16;
    inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )->defaultHighInputLatency;
    inputParameters.hostApiSpecificStreamInfo = NULL;

    /* output device */

    if (deviceInfo->maxOutputChannels == 1)
        outputChannels = 1;
    else
        outputChannels = 2;

    outputParameters.device = devNum;
    outputParameters.channelCount = outputChannels;
    outputParameters.sampleFormat = paInt16;
    outputParameters.suggestedLatency = Pa_GetDeviceInfo( outputParameters.device )->defaultHighOutputLatency;
    outputParameters.hostApiSpecificStreamInfo = NULL;

    /* open port audio for full duplex operation */

    err = Pa_OpenStream(
              &stream,
              &inputParameters,
              &outputParameters,
              fssc,
              n48,         /* changed from 0 to n48 to get Rpi audio to work without clicks */
              paClipOff,
              NULL,        /* no callback, use blocking API */
              NULL );

    if (err != paNoError) {
        fprintf(stderr, "Couldn't initialise sound device\n");
        exit(1);
    }

    err = Pa_StartStream(stream);
    if (err != paNoError) {
        fprintf(stderr, "Couldn't start sound device\n");
        exit(1);
    }
/* init UDP sender */
    int sockfd = 0;
    struct sockaddr_in addr_con;
    int addrlen = sizeof(addr_con);
    addr_con.sin_family = AF_INET;
    addr_con.sin_port = htons(SERVICE_PORT);
    addr_con.sin_addr.s_addr = inet_addr(ipAddressString);
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);

    /* Start UDP listener thread */

    if (udp_en)
        start_udp_listener_thread();

    /* Init for main loop ----------------------------------------------------------------------------*/

    fprintf(stderr, "\nCtrl-C to exit\n");
    fprintf(stderr, "freedv_mode: %d\n", freedv_mode);
    fprintf(stderr, "trigger string: %s\ntxFileName: %s bInt: %d en: %d\n", triggerString, txFileName, beaconInt, ident_en);
    fprintf(stderr, "PortAudio devNum: %d\nsamplerate: %d\n", devNum, fssc);
    fprintf(stderr, "WaveFileWritePath: %s\n", waveFileWritePath);
    fprintf(stderr, "statusPageFile: %s\n", statusPageFileName);
    fprintf(stderr, "ip_address: %s\n", ipAddressString);
    if (com_handle != COM_HANDLE_INVALID) {
        fprintf(stderr, "Comm Port for PTT: %s\n", commport);
    }
    if (*rpigpio) {
        fprintf(stderr, "Raspberry Pi BCM GPIO for PTT: %s\n", rpigpio);
    }
    if (*rpigpioalive) {
        fprintf(stderr, "Raspberry Pi BCM GPIO for Alive Indicator: %s\n", rpigpioalive);
    }

    signal(SIGINT, intHandler);  /* ctrl-C to exit gracefully */
    keepRunning = 1;
    ptxtMsgRx = txtMsgRx;
    triggered = 0;
    txFromNet = 0;
    logTimer = 0;
    syncTimer = 0;
    haveRecording = 0;

    if (com_handle != COM_HANDLE_INVALID) {
        lowerRTS(); lowerDTR();
    }

    /* -t flag: we are leaping straight into TX */

    fprintf(stderr, "Entering State == STX test %d\n", state);
    if (state == STX) {
        if (com_handle != COM_HANDLE_INVALID) {
            raiseRTS(); raiseDTR();
        }
        if (*rpigpio) {
            sys_gpio(rpigpio_path, "1");
        }
        if (my_rig)
            hamlib_ptt_on();
        sfPlayFile = openPlayFile(txFileName, &sfFs);
    }
    /* We need to work out how many samples the demod needs on each
       call (nin).  This is used to adjust for differences in the tx
       and rx sample clock frequencies.  Note also the number of
       output speech samples "nout" is time varying. */
    /* Get some numbers */
    /* demo of codecrx mode - separate demodulation and speech decoding */
    int bits_per_codec_frame = freedv_get_bits_per_codec_frame(f2);
    int bits_per_modem_frame = freedv_get_bits_per_modem_frame(f2);
    int bytes_per_codec_frame = (bits_per_codec_frame + 7) / 8;
    int bytes_per_modem_frame = (bits_per_modem_frame + 7) / 8;
//  int codec_frames = bits_per_modem_frame / bits_per_codec_frame;
//  int samples_per_frame = codec2_samples_per_frame(c2);
//  unsigned char encoded[bytes_per_codec_frame * codec_frames];
//  unsigned char rawdata[bytes_per_modem_frame];
    /* Rx */
    short demod_in[freedv_get_n_max_modem_samples(f2)];
    short speech_out[freedv_get_n_speech_samples(f2) + 4]; // note, extra shorts
    /* transmit stuff */

    fprintf(stderr, "bits_per_modem_frame:  %d\n", bits_per_modem_frame);
    fprintf(stderr, "bytes_per_modem_frame: %d\n", bytes_per_modem_frame);
    fprintf(stderr, "bits_per_codec_frame:  %d\n", bits_per_codec_frame);
    fprintf(stderr, "bytes_per_codec_frame: %d\n", bytes_per_codec_frame);
    modem_stats_open(&g_stats);
    nin = freedv_get_n_max_speech_samples(f2);
    /* set arrays */
    memset(c2packed, 0xaa, sizeof(unsigned char)*200);

    fprintf(stderr, " Entering Main loop\n");
    /* Main loop -------------------------------------------------------------------------------------*/

    while(keepRunning) {
//    fprintf(stderr, " In Main loop\n");

        if (state != STX) {


            /* Read samples from sound card, resample to modem sample rate */

            Pa_ReadStream(stream, stereo, n48);

            if (inputChannels == 2) {
                for(j=0; j<n48; j++)
                    rx48k[j] = stereo[2*j]; /* left channel only */
            }
            else {
                for(j=0; j<n48; j++)
                    rx48k[j] = stereo[j];
            }
            //fwrite(rx48k, sizeof(short), n8m, ftmp);
            int n8m_out = resample(rxsrc, rxfsm, rx48k, fsm, fssc, n8m, n48);

            /* crude input signal level meter */
            peak = 0;
            for (j=0; j<n8m_out; j++)
                if (rxfsm[j] > peak)
                    peak = rxfsm[j];

            codec2_fifo_write(fifo, rxfsm, n8m_out);

            /* demodulate to decoded speech samples */

            memset(speech_out, 0, sizeof(short)*freedv_get_n_speech_samples(f2));
            nin = freedv_nin(f2);
            while (codec2_fifo_read(fifo, demod_in, nin) == 0) {
                /* decode */
                nout = freedv_rx(f2, &speech_out[2], demod_in);
                nin = freedv_nin(f2);
                nframes = f2->n_codec_frames;
                /* get raw c2 frame bits, one bit per char or packed, mode? */
                c2bits = f2->rx_payload_bits;
/*
 bits_per_modem_frame:  112
 bytes_per_modem_frame: 14
 bits_per_codec_frame:  28
 bytes_per_codec_frame: 4 (packed)
 freedv_pack() processes bits_per_codec_frame ie. 28 bits
 freedv_unpack() processes bits_per_codec_frame ie. 28 bits
*/
                c2packedp = c2packed;
                for (int i = 0; i < nframes; i++) {
                    freedv_pack(c2packedp, c2bits + i*bits_per_codec_frame, bits_per_modem_frame);
                    c2packedp += bytes_per_codec_frame;
                }
                /* Rx decoded, Check FEC */
                int FECnow = freedv_get_total_bit_errors(f2);
                FECerr = FECnow - FEClast;
                FEClast = FECnow;
		sync += freedv_get_sync(f2); // to be sure

/* Save rawdata unpacked_payload_bits for retransmission */
                if (sync && (FECerr < FECmax) && triggered) {
                    memcpy(rxDataPtr, c2bits, bits_per_modem_frame);
                    rxDataPtr += bits_per_modem_frame;
                }
/*
                if (sync) fwrite(aaaa, sizeof(unsigned char), 16, ftmp);
                if (sync) fwrite(aaaa, sizeof(unsigned char), 16, ftmp);
                if (sync) fwrite(c2bits, sizeof(unsigned char), 112, ftmp);
                if (sync) fwrite(aaaa, sizeof(unsigned char), 16, ftmp);
                if (sync) fwrite(c2packed, sizeof(unsigned char), 32, ftmp);
 */

                if (FECerr && (ncodec != bytes_per_modem_frame))  ncodec = 0;
                if (FECerr > 4) {  /* Rubbish data */
                    not_sync++;
                    memset(speech_out, 0, sizeof(short)*freedv_get_n_speech_samples(f2));
                    nout = 0;
                }

                freedv_get_modem_stats(f2, &sync, &snr_est);
                if (freedv_mode == FREEDV_MODE_700E) {
                    freedv_get_modem_extended_stats(f2, &g_stats);
                    if (g_stats.sync_metric > METRIC ) sync |= 8;
                    if (g_stats.sync) sync |= 4;
                }
//              if (sync)
//                  fprintf(stderr, "FECerr: %d nframes: %d *c2bits: %4x %4x\n", FECerr, nframes, (int)c2bits[0], (int)c2bits[1]);
                /* Save to files and memory */
                if (sfRecFileFromRadio)
                    sf_write_short(sfRecFileFromRadio, demod_in, nin);
                if (sfRecFileDecAudio)
                    sf_write_short(sfRecFileDecAudio, &speech_out[2], nout);
                if (frxData) {
                    if (sync && (FECerr < FECmax))
                        fwrite(c2packed, sizeof(unsigned char), bytes_per_codec_frame*nframes, frxData);
                    rxDataCnt = rxData; // for Tx
                    if ((rxDataPtr - rxData) > 199000) {
                        rxDataPtr = rxData;
                        fprintf(stderr, "Rx data overrun, talked too long.\n");
                    }
                }
/* Send UDP */
                if ((sockfd > 0) && (triggered > 0) && (nout > 100)) {
                    speech_out[0] = 0x4141; // insert the data type
                    speech_out[1] = (short)nout;
                    sendto(sockfd, (char*)speech_out, (nout * 2) + 4, 0,
                        (struct sockaddr*)&addr_con, addrlen);
                }
                tnout += nin;
                if (tnout > mnout) {
                    getTimeStr(timeStr);
                    fprintf(stderr, "Rx timeout %d %s .\n", tnout, timeStr);
                    if (sfRecFileFromRadio)
                        sf_close(sfRecFileFromRadio);
                    sfRecFileFromRadio = NULL;
                    if (sfRecFileDecAudio)
                        sf_close(sfRecFileDecAudio);
                    sfRecFileDecAudio = NULL;
                    char finished[16] = {0x41, 0x42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                    sendto(sockfd, finished,  16, 0, (struct sockaddr*)&addr_con, addrlen);
                    if (frxData) {
                        fclose(frxData);
                        frxData = NULL;
                        rxDataCnt = rxData;
                    }
                    triggered = 0;
                    tnout = 0;

                }
            } // end codec2_fifo_read
        } // end state != STX


        if (state == STX) {
            short mod_out[freedv_get_n_max_modem_samples(f2)];
            COMP mod_out_comp[freedv_get_n_max_modem_samples(f2)];
            short speech_in[freedv_get_n_speech_samples(f2)];
            int txCnt;
            if( rxDataPtr > rxData) { // now send rxData
                txCnt = rxDataPtr - rxData;
//              bytes_per_codec_frame = 4 ?? 3.5
//              bytes_per_modem_frame = 14;
                if( rxDataCnt <= (rxDataPtr  - bits_per_modem_frame)) {
/* Forget the freedv_api to modulate already encoded packed_payload_bits */
//              freedv_rawdatatx(f2, mod_out, rxDataCnt); // uses 112 bits_per_modem_frame
//              freedv_rawdatacomptx(f2, mod_out_comp, rxDataCnt);
                memcpy(f2->tx_payload_bits, rxDataCnt, bits_per_modem_frame);
                rxDataCnt +=  bits_per_modem_frame;
                freedv_comptx_ofdm(f2, mod_out_comp);
/* convert to real */
                for(int i=0; i<f2->n_nat_modem_samples; i++) // convert to real
                    mod_out[i] = mod_out_comp[i].real;

                } else {
                rxDataCnt = rxDataPtr = rxData;
                }
            }


/* get audio from network fifo */
            if (txFromNet == 1) {
                if (codec2_fifo_read(nfifo, speech_in, n8m) == 0) {
                    freedv_tx(f2, mod_out, speech_in);
                } else {
                    txFromNet = 0; 
                }
            } 
            if (sfPlayFile != NULL && txFromNet == 0 && rxDataPtr == rxData) {
                /* resample input sound file as can't guarantee 8KHz sample rate */

                unsigned int nsf = freedv_get_n_speech_samples(f2)*sfFs/FS8;
                short        insf[nsf];
                unsigned int n = sf_read_short(sfPlayFile, insf, nsf);
                resample(playsrc, speech_in, insf, FS8, sfFs, freedv_get_n_speech_samples(f2), nsf);

                //fwrite(speech_in, sizeof(short), freedv_get_n_nom_modem_samples(f2), ftmp);

                if (n != nsf) {
                    /* end of file - this signals state machine we've finished */
                    sf_close(sfPlayFile);
                    sfPlayFile = NULL;
                    beaconTimer = 0;
                    if (verbose || triggered) fprintf(stderr, "\n== Done Parrot send! %d  %s %s ==\n", txCnt, timeStr, rxDataFileName);
                    triggered = 0;
                }
            freedv_tx(f2, mod_out, speech_in);
            } // end if sfPlayFile

            //fwrite(mod_out, sizeof(short), freedv_get_n_nom_modem_samples(f2), ftmp);

            int n48_out = resample(txsrc, tx48k, mod_out, fssc, fsm, n48, n8m);
            //printf("n48_out: %d n48: %d n_nom: %d\n", n48_out, n48, n8m);
            //fwrite(tx48k, sizeof(short), n48_out, ftmp);
            for(j=0; j<n48_out; j++) {
                if (outputChannels == 2) {
                    stereo[2*j] = tx48k[j];   // left channel
                    stereo[2*j+1] = tx48k[j]; // right channel
                }
                else {
                    stereo[j] = tx48k[j];     // mono
                }
            }

            Pa_WriteStream(stream, stereo, n48_out);
        }

        /* state machine processing */

        next_state = state;

        switch(state) {

        case SRX_IDLE:
            if (sync > 0) {
                next_state = SRX_MAYBE_SYNC;
                syncTimer = 0.0;
                *txtMsgRx = 0;
                ptxtMsgRx = txtMsgRx;
                freedv_set_total_bit_errors(f2, 0);
                freedv_set_total_bits(f2, 0);
            }
            break;

        case SRX_MAYBE_SYNC:
            if (sync > 0) {
                syncTimer += dT;
                if (syncTimer >= SYNC_TIMER) {

                    /* OK we really are in sync */

                    next_state = SRX_SYNC;
                }
            }
            else {
                next_state = SRX_IDLE;
                triggered = 0;
                haveRecording = 0;
            }
            break;

        case SRX_SYNC:
            syncTimer += dT;
            if (!sync) {
                syncTimer = 0;
                next_state = SRX_MAYBE_UNSYNC;
            }

            /* if triggered kick off recording of two files */

            if ((triggered || recordAny) && !haveRecording) {

                char recFileFromRadioName[MAX_CHAR2], recFileDecAudioName[MAX_CHAR2];

                getTimeStr(timeStr); // time now
                sprintf(recFileFromRadioName,"%s/%s_from_radio.wav", waveFileWritePath, timeStr);
                sprintf(recFileDecAudioName,"%s/%s_decoded_speech.wav", waveFileWritePath, timeStr);
                sprintf(rxDataFileName,"%s/%s_rxData.700C", waveFileWritePath, timeStr);
                sfRecFileFromRadio = openRecFile(recFileFromRadioName, fsm);
                sfRecFileDecAudio = openRecFile(recFileDecAudioName, FS8);
                frxData = fopen(rxDataFileName, "wb");
                rxDataPtr = rxDataCnt = rxData;
                haveRecording = 1;
                if (freedv_mode != FREEDV_MODE_700C) {
		              recordAny = 0;
		            }
                tnout = 0;
            }

            break;

        case SRX_MAYBE_UNSYNC:
            if (!sync) {
                syncTimer += dT;
                if (syncTimer >= UNSYNC_TIMER) {
                    /* we really are out of sync */

                    /* finish up any open recording files */

                    if (sfRecFileFromRadio)
                        sf_close(sfRecFileFromRadio);
                    sfRecFileFromRadio = NULL;
                    if (sfRecFileDecAudio) 
                        sf_close(sfRecFileDecAudio);
                    sfRecFileDecAudio = NULL;
                        char finished[16] = {0x41, 0x43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                        sendto(sockfd, finished,  16, 0,
                            (struct sockaddr*)&addr_con, addrlen);
                    if (frxData)
                        fclose(frxData);
                    frxData = NULL;

                    /* kick off a tx if triggered */

                    if (triggered) {
                        float ber = (float)freedv_get_total_bit_errors(f2)/freedv_get_total_bits(f2);
                        char tmpStr[MAX_CHAR];

                        sprintf(tmpStr, "SNR: %3.1f BER: %4.3f de %s\r",
                                snr_sample, ber, callsign);
			/* Alan99 */
                        sprintf(tmpStr, "Trigger with ++ eg. ++ de %s\r", callsign);
                        strcpy(txtMsgTx, tmpStr);
                        fprintf(stderr, "TX txtMsg: %s\n", txtMsgTx);
                        ptxtMsgTx = txtMsgTx;
                        sfPlayFile = openPlayFile(txFileName, &sfFs);

                        if (com_handle != COM_HANDLE_INVALID) {
                            raiseRTS(); raiseDTR();
                        }
                        if (*rpigpio) {
                            sys_gpio(rpigpio_path, "1");
                        }
                        if (my_rig)
                            hamlib_ptt_on();
                        next_state = STX;
                    }
                    else {
                        next_state = SRX_IDLE;
                        triggered = 0;
                        haveRecording = 0;
                    }
                }
            }
            else
                next_state = SRX_SYNC; /* sync is back so false alarm */
            break;

        case STX:
            if ((sfPlayFile == NULL) && (txFromNet == 0)) {

                if (com_handle != COM_HANDLE_INVALID) {
                    lowerRTS(); lowerDTR();
                }
                if (*rpigpio) {
                    sys_gpio(rpigpio_path, "0");
                }
                if (my_rig)
                    hamlib_ptt_off();
                next_state = SRX_IDLE;
                triggered = 0;
                haveRecording = 0;
            }
            break;
        }

        /* end switch statement for case statement */

        logTimer += dT;
        if (logTimer >= LOG_TIMER) {
            logTimer = 0;
            if (verbose) {
                fprintf(stderr, "state: %-14s  peak: %6d  sync: %d  FECerr %d metric: %2.2f SNR: %3.1f foff: %3.1f trig: %d rcd: %d\n",
                        state_str[state], peak, sync, FECerr, g_stats.sync_metric, snr_est, g_stats.foff, triggered, recordAny);
            }
            if (*statusPageFileName) {
                char timeStr[MAX_CHAR];
                time_t ltime;     /* calendar time */
                ltime=time(NULL); /* get current cal time */

                sprintf(timeStr, "%s",asctime( localtime(&ltime) ) );
                strtok(timeStr, "\n");

                fstatus = fopen(statusPageFileName, "wt");
                if (fstatus != NULL) {
                    fprintf(fstatus, "<html>\n<head>\n<meta http-equiv=\"refresh\" content=\"2\">\n</head>\n<body>\n");
                    fprintf(fstatus, "%s: state: %s peak: %d sync: %d SNR: %3.1f triggered: %d recordany: %d txtmsg: %s\n",
                            timeStr, state_str[state], peak, sync, snr_est, triggered, recordAny, txtMsgRx);
                    fprintf(fstatus, "</body>\n</html>\n");
                    fclose(fstatus);
                }
            }

            /* toggle alive GPIO */

            if (*rpigpioalive) {
                if (gpioAliveState) {
                    gpioAliveState = 0;
                    sys_gpio(rpigpioalive_path, "0");
                } else {
                    gpioAliveState = 1;
                    sys_gpio(rpigpioalive_path, "1");
                }
            }
            if ( !sync) {
               if ( (txFromNet == 1) || ((beaconTimer++ > beaconInt) && ident_en) ) {
                    beaconTimer = 0; triggered = 1;
                    sprintf(rxDataFileName, "Ident");
                    getTimeStr(timeStr);
                //  sprintf(txtMsgTx, "700E Test by %s\r", callsign);
		/* Alan99 */
                    sprintf(txtMsgTx, "Trigger with + de %s\r", callsign);
                    ptxtMsgTx = txtMsgTx;
                    if (sfPlayFile == NULL)
                        sfPlayFile = openPlayFile(txFileName, &sfFs);

                    if (com_handle != COM_HANDLE_INVALID) {
                        raiseRTS(); raiseDTR();
                    }
                    if (*rpigpio) {
                        sys_gpio(rpigpio_path, "1");
                    }
                    if (my_rig)
                        hamlib_ptt_on();
                    next_state = STX;
               }
            }
        } // end logTimer

        state = next_state;
    } /* end while loop */


    /* Ctrl-C has been pressed lets shut down gracefully ------------------*/

    /* lower PTT lines, shut down ports */

    if (com_handle != COM_HANDLE_INVALID) {
        lowerRTS(); lowerDTR();
        closeComPort();
    }
    if (*rpigpio) {
        sys_gpio(rpigpio_path, "0");
        sys_gpio("/sys/class/gpio/unexport", rpigpio);
    }

    if (*rpigpioalive) {
        sys_gpio(rpigpioalive_path, "0");
        sys_gpio("/sys/class/gpio/unexport", rpigpioalive);
    }

    if (my_rig) {
        hamlib_ptt_off();
        rig_close(my_rig);
        rig_cleanup(my_rig);
    }

    /* Shut down port audio */

    err = Pa_StopStream(stream);
    if (err != paNoError) {
        fprintf(stderr, "Couldn't stop sound device\n");
        exit(1);
    }
    Pa_CloseStream(stream);
    Pa_Terminate();

    /* clean up states */

    codec2_fifo_destroy(fifo);
    src_delete(rxsrc);
    src_delete(txsrc);
    src_delete(playsrc);
    freedv_close(f2);
    if (sfRecFileFromRadio)
        sf_close(sfRecFileFromRadio);
    if (sfRecFileDecAudio)
        sf_close(sfRecFileDecAudio);
    if (frxData)
        fclose(frxData);
//  fclose(ftmp);

    return 0;
}


/*--------------------------------------------------------------------------------------------------------*\

                                      Comm port fuctions lifted from FreeDV

\*--------------------------------------------------------------------------------------------------------*/

//----------------------------------------------------------------
// openComPort() opens the com port specified by the string
// ie: "/dev/ttyUSB0"
//----------------------------------------------------------------

int openComPort(const char *name)
{
    if(com_handle != COM_HANDLE_INVALID)
        closeComPort();

#ifdef _WIN32
	{
		COMMCONFIG CC;
		DWORD CCsize=sizeof(CC);
		COMMTIMEOUTS timeouts;
		DCB	dcb;

		if(GetDefaultCommConfigA(name, &CC, &CCsize)) {
			CC.dcb.fOutxCtsFlow		= FALSE;
			CC.dcb.fOutxDsrFlow		= FALSE;
			CC.dcb.fDtrControl		= DTR_CONTROL_DISABLE;
			CC.dcb.fDsrSensitivity	= FALSE;
			CC.dcb.fRtsControl		= RTS_CONTROL_DISABLE;
			SetDefaultCommConfigA(name, &CC, CCsize);
		}

		if((com_handle=CreateFileA(name
			,GENERIC_READ|GENERIC_WRITE 	/* Access */
			,0								/* Share mode */
			,NULL							/* Security attributes */
			,OPEN_EXISTING					/* Create access */
			,FILE_ATTRIBUTE_NORMAL			/* File attributes */
			,NULL							/* Template */
			))==INVALID_HANDLE_VALUE)
			return false;

		if(GetCommTimeouts(com_handle, &timeouts)) {
			timeouts.ReadIntervalTimeout=MAXDWORD;
			timeouts.ReadTotalTimeoutMultiplier=0;
			timeouts.ReadTotalTimeoutConstant=0;		// No-wait read timeout
			timeouts.WriteTotalTimeoutMultiplier=0;
			timeouts.WriteTotalTimeoutConstant=5000;	// 5 seconds
			SetCommTimeouts(com_handle,&timeouts);
		}

		/* Force N-8-1 mode: */
		if(GetCommState(com_handle, &dcb)==TRUE) {
			dcb.ByteSize		= 8;
			dcb.Parity			= NOPARITY;
			dcb.StopBits		= ONESTOPBIT;
			dcb.DCBlength		= sizeof(DCB);
			dcb.fBinary			= TRUE;
			dcb.fOutxCtsFlow	= FALSE;
			dcb.fOutxDsrFlow	= FALSE;
			dcb.fDtrControl		= DTR_CONTROL_DISABLE;
			dcb.fDsrSensitivity	= FALSE;
			dcb.fTXContinueOnXoff= TRUE;
			dcb.fOutX			= FALSE;
			dcb.fInX			= FALSE;
			dcb.fRtsControl		= RTS_CONTROL_DISABLE;
			dcb.fAbortOnError	= FALSE;
			SetCommState(com_handle, &dcb);
		}
	}
#else
    {
        struct termios t;

        if((com_handle=open(name, O_NONBLOCK|O_RDWR))==COM_HANDLE_INVALID)
            return -1;

        if(tcgetattr(com_handle, &t)==-1) {
            close(com_handle);
            com_handle = COM_HANDLE_INVALID;
            return -1;
        }

        t.c_iflag = (
                     IGNBRK   /* ignore BREAK condition */
                     | IGNPAR   /* ignore (discard) parity errors */
                     );
        t.c_oflag = 0;	/* No output processing */
        t.c_cflag = (
                     CS8         /* 8 bits */
                     | CREAD       /* enable receiver */
                     /*
                       Fun snippet from the FreeBSD manpage:

                       If CREAD is set, the receiver is enabled.  Otherwise, no character is
                       received.  Not all hardware supports this bit.  In fact, this flag is
                       pretty silly and if it were not part of the termios specification it
                       would be omitted.
                     */
                     | CLOCAL      /* ignore modem status lines */
                     );
        t.c_lflag = 0;	/* No local modes */
        if(tcsetattr(com_handle, TCSANOW, &t)==-1) {
            close(com_handle);
            com_handle = COM_HANDLE_INVALID;
            return -1;
        }

    }
#endif

    return 0;
}

void closeComPort(void)
{
#ifdef _WIN32
	CloseHandle(com_handle);
#else
    close(com_handle);
#endif
    com_handle = COM_HANDLE_INVALID;
}

//----------------------------------------------------------------
// (raise|lower)(RTS|DTR)()
//
// Raises/lowers the specified signal
//----------------------------------------------------------------

void raiseDTR(void)
{
    if(com_handle == COM_HANDLE_INVALID)
        return;
#ifdef _WIN32
	EscapeCommFunction(com_handle, SETDTR);
#else
    {	// For C89 happiness
        int flags = TIOCM_DTR;
        ioctl(com_handle, TIOCMBIS, &flags);
    }
#endif
}


void raiseRTS(void)
{
    if(com_handle == COM_HANDLE_INVALID)
        return;
#ifdef _WIN32
	EscapeCommFunction(com_handle, SETRTS);
#else
    {	// For C89 happiness
        int flags = TIOCM_RTS;
        ioctl(com_handle, TIOCMBIS, &flags);
    }
#endif
}

void lowerDTR(void)
{
    if(com_handle == COM_HANDLE_INVALID)
        return;

#ifdef _WIN32
	EscapeCommFunction(com_handle, CLRDTR);
#else
    {	// For C89 happiness
        int flags = TIOCM_DTR;
        ioctl(com_handle, TIOCMBIC, &flags);
    }
#endif
}

void lowerRTS(void)
{
    if(com_handle == COM_HANDLE_INVALID)
        return;
#ifdef _WIN32
	EscapeCommFunction(com_handle, CLRRTS);
#else
    {	// For C89 happiness
        int flags = TIOCM_RTS;
        ioctl(com_handle, TIOCMBIC, &flags);
    }
#endif
}

#define BUFSIZE          2048

void *udp_listener_thread(void* p) {
    struct sockaddr_in myaddr;	/* our address */
    struct sockaddr_in remaddr;	/* remote address */
    socklen_t addrlen = sizeof(remaddr);		/* length of addresses */
    int recvlen;			/* # bytes received */
    int fd;				/* our socket */
    char txt[BUFSIZE];	/* receive buffer */
    short *txtp;
    txtp = (short*)&txt[0];

    /* create a UDP socket */

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        fprintf(stderr, "cannot create socket\n");
        return 0;
    }

    /* bind the socket to any valid IP address and a specific port */

    memset((char *)&myaddr, 0, sizeof(myaddr));
    myaddr.sin_family = AF_INET;
    myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    myaddr.sin_port = htons(SERVICE_PORT);

    if (bind(fd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {
        fprintf(stderr, "bind failed");
        return 0;
    }

    /* now loop, receiving data and printing what we received */

    while (runListener) {
        fprintf(stderr, "udp listener waiting on port %d - send me a command!\n", SERVICE_PORT);
        recvlen = recvfrom(fd, txt, BUFSIZE, 0, (struct sockaddr *)&remaddr, &addrlen);
        fprintf(stderr, "received %d bytes\n", recvlen);
        if ((recvlen > 0) && (recvlen < 20)) {
            txt[recvlen] = 0;
            fprintf(stderr, "txt: %s\n", txt);
            if (strcmp(txt, "recordany") == 0) {
                recordAny = 1;
                fprintf(stderr, "Next signal to sync will be recorded regardless of txt msg\n");
            }
            if (strcmp(txt, "trigger") == 0) {
                triggered = 1;
                fprintf(stderr, "Now triggered\n");
            }
        } 
/* audio to send */
/* receive net audio, first short 0x4141, then length */
        if (txtp[0] == 0x4141) {
            if (txtp[1] > 14) {
                codec2_fifo_write(nfifo, &txtp[2], (recvlen / 2) - 2);
                txFromNet = 1;
            } else {
                txFromNet = 0;
            }
        }
    }

    return NULL;
}


pthread_t start_udp_listener_thread(void) {
    pthread_t athread;

    runListener = 1;

    if (pthread_create(&athread, NULL, udp_listener_thread, NULL) != 0)
        fprintf(stderr, "Can't create UDP listener thread\n");

    return athread;
}
